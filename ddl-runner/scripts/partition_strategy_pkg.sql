-- =====================================================
-- Oracle Partition Strategy Management Package
-- Advanced partition strategy handling and migration
-- Author: Principal Oracle Database Application Engineer
-- Version: 1.0
-- =====================================================

-- Create strategy configuration table
CREATE TABLE partition_strategy_config (
    config_id          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name         VARCHAR2(128) NOT NULL,
    strategy_type      VARCHAR2(20) NOT NULL,
    partition_column   VARCHAR2(128) NOT NULL,
    interval_value     VARCHAR2(50),
    tablespace_prefix  VARCHAR2(30),
    retention_days     NUMBER DEFAULT 90,
    auto_maintenance   CHAR(1) DEFAULT 'Y',
    created_date       DATE DEFAULT SYSDATE,
    created_by         VARCHAR2(30) DEFAULT USER,
    last_modified      DATE DEFAULT SYSDATE,
    last_modified_by   VARCHAR2(30) DEFAULT USER,
    is_active          CHAR(1) DEFAULT 'Y',
    CONSTRAINT chk_strategy_type CHECK (strategy_type IN ('RANGE', 'LIST', 'HASH', 'INTERVAL', 'REFERENCE', 'SYSTEM')),
    CONSTRAINT chk_auto_maintenance CHECK (auto_maintenance IN ('Y', 'N')),
    CONSTRAINT chk_is_active CHECK (is_active IN ('Y', 'N'))
);

-- Create indexes
CREATE UNIQUE INDEX idx_part_strategy_table ON partition_strategy_config(table_name, is_active);
CREATE INDEX idx_part_strategy_type ON partition_strategy_config(strategy_type);

-- Package Specification
CREATE OR REPLACE PACKAGE partition_strategy_pkg
AUTHID CURRENT_USER
AS
    -- Types for strategy management
    TYPE strategy_config_rec IS RECORD (
        config_id          NUMBER,
        table_name         VARCHAR2(128),
        strategy_type      VARCHAR2(20),
        partition_column   VARCHAR2(128),
        interval_value     VARCHAR2(50),
        tablespace_prefix  VARCHAR2(30),
        retention_days     NUMBER,
        auto_maintenance   BOOLEAN,
        created_date       DATE,
        created_by         VARCHAR2(30),
        last_modified      DATE,
        last_modified_by   VARCHAR2(30),
        is_active          BOOLEAN
    );
    
    TYPE partition_analysis_rec IS RECORD (
        table_name         VARCHAR2(128),
        current_strategy   VARCHAR2(20),
        partition_count    NUMBER,
        total_size_mb      NUMBER,
        avg_partition_size_mb NUMBER,
        max_partition_size_mb NUMBER,
        min_partition_size_mb NUMBER,
        last_analyzed      DATE,
        recommended_strategy VARCHAR2(20),
        migration_complexity VARCHAR2(20)
    );
    
    TYPE partition_analysis_tab IS TABLE OF partition_analysis_rec;
    
    -- Strategy configuration procedures
    PROCEDURE create_strategy_config(
        p_table_name        IN VARCHAR2,
        p_strategy_type     IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_interval_value    IN VARCHAR2 DEFAULT NULL,
        p_tablespace_prefix IN VARCHAR2 DEFAULT NULL,
        p_retention_days    IN NUMBER DEFAULT 90,
        p_auto_maintenance  IN BOOLEAN DEFAULT TRUE
    );
    
    PROCEDURE update_strategy_config(
        p_table_name        IN VARCHAR2,
        p_strategy_type     IN VARCHAR2 DEFAULT NULL,
        p_partition_column  IN VARCHAR2 DEFAULT NULL,
        p_interval_value    IN VARCHAR2 DEFAULT NULL,
        p_tablespace_prefix IN VARCHAR2 DEFAULT NULL,
        p_retention_days    IN NUMBER DEFAULT NULL,
        p_auto_maintenance  IN BOOLEAN DEFAULT NULL
    );
    
    PROCEDURE deactivate_strategy_config(
        p_table_name IN VARCHAR2
    );
    
    FUNCTION get_strategy_config(
        p_table_name IN VARCHAR2
    ) RETURN strategy_config_rec;
    
    -- Strategy migration procedures
    PROCEDURE migrate_to_range_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_definitions IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    );
    
    PROCEDURE migrate_to_list_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_definitions IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    );
    
    PROCEDURE migrate_to_hash_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_count   IN NUMBER,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    );
    
    PROCEDURE migrate_to_interval_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_interval_value    IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    );
    
    PROCEDURE migrate_to_reference_partitioning(
        p_table_name        IN VARCHAR2,
        p_parent_table      IN VARCHAR2,
        p_foreign_key       IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    );
    
    -- Strategy analysis procedures
    FUNCTION analyze_table_for_partitioning(
        p_table_name IN VARCHAR2
    ) RETURN partition_analysis_rec;
    
    FUNCTION get_partitioning_recommendations(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR;
    
    FUNCTION analyze_partition_effectiveness(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR;
    
    -- Strategy optimization procedures
    PROCEDURE optimize_partition_strategy(
        p_table_name IN VARCHAR2,
        p_force_recommendation IN BOOLEAN DEFAULT FALSE
    );
    
    PROCEDURE rebalance_partitions(
        p_table_name IN VARCHAR2,
        p_target_size_mb IN NUMBER DEFAULT 1000
    );
    
    PROCEDURE consolidate_small_partitions(
        p_table_name IN VARCHAR2,
        p_min_size_mb IN NUMBER DEFAULT 100
    );
    
    -- Strategy validation procedures
    FUNCTION validate_partition_strategy(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR;
    
    PROCEDURE validate_partition_columns(
        p_table_name IN VARCHAR2,
        p_partition_column IN VARCHAR2
    );
    
    -- Strategy monitoring procedures
    FUNCTION get_strategy_usage_stats(
        p_table_name IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    PROCEDURE monitor_strategy_performance(
        p_table_name IN VARCHAR2
    );
    
    -- Utility procedures
    PROCEDURE generate_migration_script(
        p_table_name        IN VARCHAR2,
        p_target_strategy   IN VARCHAR2,
        p_script_type       IN VARCHAR2 DEFAULT 'DDL' -- DDL, DML, COMPLETE
    );
    
    PROCEDURE estimate_migration_impact(
        p_table_name        IN VARCHAR2,
        p_target_strategy   IN VARCHAR2
    );
    
    PROCEDURE rollback_strategy_migration(
        p_table_name IN VARCHAR2,
        p_backup_table IN VARCHAR2
    );
    
END partition_strategy_pkg;
/

-- Package Body
CREATE OR REPLACE PACKAGE BODY partition_strategy_pkg
AS
    -- Private procedure for autonomous logging
    PROCEDURE log_strategy_operation(
        p_operation       IN VARCHAR2,
        p_table_name      IN VARCHAR2,
        p_strategy_type   IN VARCHAR2 DEFAULT NULL,
        p_status          IN VARCHAR2,
        p_message         IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO partition_operation_log (
            operation_id,
            operation_type,
            table_name,
            partition_name,
            status,
            message,
            operation_time,
            user_name
        ) VALUES (
            partition_operation_log_seq.NEXTVAL,
            'STRATEGY_' || p_operation,
            p_table_name,
            p_strategy_type,
            p_status,
            p_message,
            SYSTIMESTAMP,
            USER
        );
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Silent fail for logging
            NULL;
    END log_strategy_operation;
    
    -- Private function to check if table exists
    FUNCTION table_exists(
        p_table_name IN VARCHAR2
    ) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_count
        FROM user_tables
        WHERE table_name = UPPER(p_table_name);
        
        RETURN v_count > 0;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END table_exists;
    
    -- Private function to check if table is partitioned
    FUNCTION is_partitioned(
        p_table_name IN VARCHAR2
    ) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_count
        FROM user_tables
        WHERE table_name = UPPER(p_table_name)
        AND partitioned = 'YES';
        
        RETURN v_count > 0;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END is_partitioned;
    
    -- Strategy configuration procedures
    PROCEDURE create_strategy_config(
        p_table_name        IN VARCHAR2,
        p_strategy_type     IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_interval_value    IN VARCHAR2 DEFAULT NULL,
        p_tablespace_prefix IN VARCHAR2 DEFAULT NULL,
        p_retention_days    IN NUMBER DEFAULT 90,
        p_auto_maintenance  IN BOOLEAN DEFAULT TRUE
    ) IS
    BEGIN
        -- Validate input
        IF NOT table_exists(p_table_name) THEN
            log_strategy_operation('CREATE_CONFIG', p_table_name, p_strategy_type, 'ERROR', 'Table does not exist');
            RAISE_APPLICATION_ERROR(-20001, 'Table ' || p_table_name || ' does not exist');
        END IF;
        
        -- Deactivate any existing configuration
        UPDATE partition_strategy_config
        SET is_active = 'N',
            last_modified = SYSDATE,
            last_modified_by = USER
        WHERE table_name = UPPER(p_table_name)
        AND is_active = 'Y';
        
        -- Create new configuration
        INSERT INTO partition_strategy_config (
            table_name,
            strategy_type,
            partition_column,
            interval_value,
            tablespace_prefix,
            retention_days,
            auto_maintenance,
            created_by,
            last_modified_by
        ) VALUES (
            UPPER(p_table_name),
            UPPER(p_strategy_type),
            UPPER(p_partition_column),
            p_interval_value,
            p_tablespace_prefix,
            p_retention_days,
            CASE WHEN p_auto_maintenance THEN 'Y' ELSE 'N' END,
            USER,
            USER
        );
        
        log_strategy_operation('CREATE_CONFIG', p_table_name, p_strategy_type, 'SUCCESS', 
                              'Strategy configuration created');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('CREATE_CONFIG', p_table_name, p_strategy_type, 'ERROR', SQLERRM);
            RAISE;
    END create_strategy_config;
    
    PROCEDURE update_strategy_config(
        p_table_name        IN VARCHAR2,
        p_strategy_type     IN VARCHAR2 DEFAULT NULL,
        p_partition_column  IN VARCHAR2 DEFAULT NULL,
        p_interval_value    IN VARCHAR2 DEFAULT NULL,
        p_tablespace_prefix IN VARCHAR2 DEFAULT NULL,
        p_retention_days    IN NUMBER DEFAULT NULL,
        p_auto_maintenance  IN BOOLEAN DEFAULT NULL
    ) IS
    BEGIN
        UPDATE partition_strategy_config
        SET strategy_type = NVL(UPPER(p_strategy_type), strategy_type),
            partition_column = NVL(UPPER(p_partition_column), partition_column),
            interval_value = NVL(p_interval_value, interval_value),
            tablespace_prefix = NVL(p_tablespace_prefix, tablespace_prefix),
            retention_days = NVL(p_retention_days, retention_days),
            auto_maintenance = NVL(CASE WHEN p_auto_maintenance THEN 'Y' ELSE 'N' END, auto_maintenance),
            last_modified = SYSDATE,
            last_modified_by = USER
        WHERE table_name = UPPER(p_table_name)
        AND is_active = 'Y';
        
        IF SQL%ROWCOUNT = 0 THEN
            log_strategy_operation('UPDATE_CONFIG', p_table_name, NULL, 'ERROR', 'No active configuration found');
            RAISE_APPLICATION_ERROR(-20002, 'No active configuration found for table ' || p_table_name);
        END IF;
        
        log_strategy_operation('UPDATE_CONFIG', p_table_name, p_strategy_type, 'SUCCESS', 
                              'Strategy configuration updated');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('UPDATE_CONFIG', p_table_name, p_strategy_type, 'ERROR', SQLERRM);
            RAISE;
    END update_strategy_config;
    
    PROCEDURE deactivate_strategy_config(
        p_table_name IN VARCHAR2
    ) IS
    BEGIN
        UPDATE partition_strategy_config
        SET is_active = 'N',
            last_modified = SYSDATE,
            last_modified_by = USER
        WHERE table_name = UPPER(p_table_name)
        AND is_active = 'Y';
        
        log_strategy_operation('DEACTIVATE_CONFIG', p_table_name, NULL, 'SUCCESS', 
                              'Strategy configuration deactivated');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('DEACTIVATE_CONFIG', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END deactivate_strategy_config;
    
    FUNCTION get_strategy_config(
        p_table_name IN VARCHAR2
    ) RETURN strategy_config_rec IS
        v_config strategy_config_rec;
    BEGIN
        SELECT 
            config_id,
            table_name,
            strategy_type,
            partition_column,
            interval_value,
            tablespace_prefix,
            retention_days,
            CASE WHEN auto_maintenance = 'Y' THEN TRUE ELSE FALSE END,
            created_date,
            created_by,
            last_modified,
            last_modified_by,
            CASE WHEN is_active = 'Y' THEN TRUE ELSE FALSE END
        INTO v_config
        FROM partition_strategy_config
        WHERE table_name = UPPER(p_table_name)
        AND is_active = 'Y';
        
        RETURN v_config;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            log_strategy_operation('GET_CONFIG', p_table_name, NULL, 'WARNING', 'No active configuration found');
            RETURN NULL;
        WHEN OTHERS THEN
            log_strategy_operation('GET_CONFIG', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END get_strategy_config;
    
    -- Strategy migration procedures
    PROCEDURE migrate_to_range_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_definitions IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    ) IS
        v_backup_table VARCHAR2(128);
        v_sql VARCHAR2(4000);
    BEGIN
        log_strategy_operation('MIGRATE_RANGE', p_table_name, 'RANGE', 'STARTED', 'Starting migration to range partitioning');
        
        -- Create backup table if preserving data
        IF p_preserve_data THEN
            v_backup_table := p_table_name || '_BACKUP_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISS');
            v_sql := 'CREATE TABLE ' || v_backup_table || ' AS SELECT * FROM ' || p_table_name;
            EXECUTE IMMEDIATE v_sql;
        END IF;
        
        -- Drop original table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Recreate table with range partitioning
        -- This is a simplified example - in practice, you'd parse p_partition_definitions
        v_sql := 'CREATE TABLE ' || p_table_name || ' PARTITION BY RANGE (' || p_partition_column || ') (' ||
                 'PARTITION p_default VALUES LESS THAN (MAXVALUE)' ||
                 ') AS SELECT * FROM ' || v_backup_table || ' WHERE 1=0';
        
        EXECUTE IMMEDIATE v_sql;
        
        -- Restore data if preserving
        IF p_preserve_data THEN
            EXECUTE IMMEDIATE 'INSERT INTO ' || p_table_name || ' SELECT * FROM ' || v_backup_table;
            EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table;
        END IF;
        
        -- Update strategy configuration
        create_strategy_config(p_table_name, 'RANGE', p_partition_column);
        
        log_strategy_operation('MIGRATE_RANGE', p_table_name, 'RANGE', 'SUCCESS', 'Migration completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MIGRATE_RANGE', p_table_name, 'RANGE', 'ERROR', SQLERRM);
            RAISE;
    END migrate_to_range_partitioning;
    
    PROCEDURE migrate_to_list_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_definitions IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    ) IS
        v_backup_table VARCHAR2(128);
        v_sql VARCHAR2(4000);
    BEGIN
        log_strategy_operation('MIGRATE_LIST', p_table_name, 'LIST', 'STARTED', 'Starting migration to list partitioning');
        
        -- Create backup table if preserving data
        IF p_preserve_data THEN
            v_backup_table := p_table_name || '_BACKUP_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISS');
            v_sql := 'CREATE TABLE ' || v_backup_table || ' AS SELECT * FROM ' || p_table_name;
            EXECUTE IMMEDIATE v_sql;
        END IF;
        
        -- Drop original table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Recreate table with list partitioning
        v_sql := 'CREATE TABLE ' || p_table_name || ' PARTITION BY LIST (' || p_partition_column || ') (' ||
                 'PARTITION p_default VALUES (DEFAULT)' ||
                 ') AS SELECT * FROM ' || v_backup_table || ' WHERE 1=0';
        
        EXECUTE IMMEDIATE v_sql;
        
        -- Restore data if preserving
        IF p_preserve_data THEN
            EXECUTE IMMEDIATE 'INSERT INTO ' || p_table_name || ' SELECT * FROM ' || v_backup_table;
            EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table;
        END IF;
        
        -- Update strategy configuration
        create_strategy_config(p_table_name, 'LIST', p_partition_column);
        
        log_strategy_operation('MIGRATE_LIST', p_table_name, 'LIST', 'SUCCESS', 'Migration completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MIGRATE_LIST', p_table_name, 'LIST', 'ERROR', SQLERRM);
            RAISE;
    END migrate_to_list_partitioning;
    
    PROCEDURE migrate_to_hash_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_partition_count   IN NUMBER,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    ) IS
        v_backup_table VARCHAR2(128);
        v_sql VARCHAR2(4000);
    BEGIN
        log_strategy_operation('MIGRATE_HASH', p_table_name, 'HASH', 'STARTED', 'Starting migration to hash partitioning');
        
        -- Create backup table if preserving data
        IF p_preserve_data THEN
            v_backup_table := p_table_name || '_BACKUP_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISS');
            v_sql := 'CREATE TABLE ' || v_backup_table || ' AS SELECT * FROM ' || p_table_name;
            EXECUTE IMMEDIATE v_sql;
        END IF;
        
        -- Drop original table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Recreate table with hash partitioning
        v_sql := 'CREATE TABLE ' || p_table_name || ' PARTITION BY HASH (' || p_partition_column || ') ' ||
                 'PARTITIONS ' || p_partition_count || 
                 ' AS SELECT * FROM ' || v_backup_table || ' WHERE 1=0';
        
        EXECUTE IMMEDIATE v_sql;
        
        -- Restore data if preserving
        IF p_preserve_data THEN
            EXECUTE IMMEDIATE 'INSERT INTO ' || p_table_name || ' SELECT * FROM ' || v_backup_table;
            EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table;
        END IF;
        
        -- Update strategy configuration
        create_strategy_config(p_table_name, 'HASH', p_partition_column);
        
        log_strategy_operation('MIGRATE_HASH', p_table_name, 'HASH', 'SUCCESS', 'Migration completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MIGRATE_HASH', p_table_name, 'HASH', 'ERROR', SQLERRM);
            RAISE;
    END migrate_to_hash_partitioning;
    
    PROCEDURE migrate_to_interval_partitioning(
        p_table_name        IN VARCHAR2,
        p_partition_column  IN VARCHAR2,
        p_interval_value    IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    ) IS
        v_backup_table VARCHAR2(128);
        v_sql VARCHAR2(4000);
    BEGIN
        log_strategy_operation('MIGRATE_INTERVAL', p_table_name, 'INTERVAL', 'STARTED', 'Starting migration to interval partitioning');
        
        -- Create backup table if preserving data
        IF p_preserve_data THEN
            v_backup_table := p_table_name || '_BACKUP_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISS');
            v_sql := 'CREATE TABLE ' || v_backup_table || ' AS SELECT * FROM ' || p_table_name;
            EXECUTE IMMEDIATE v_sql;
        END IF;
        
        -- Drop original table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Recreate table with interval partitioning
        v_sql := 'CREATE TABLE ' || p_table_name || ' PARTITION BY RANGE (' || p_partition_column || ') ' ||
                 'INTERVAL (' || p_interval_value || ') (' ||
                 'PARTITION p_default VALUES LESS THAN (MAXVALUE)' ||
                 ') AS SELECT * FROM ' || v_backup_table || ' WHERE 1=0';
        
        EXECUTE IMMEDIATE v_sql;
        
        -- Restore data if preserving
        IF p_preserve_data THEN
            EXECUTE IMMEDIATE 'INSERT INTO ' || p_table_name || ' SELECT * FROM ' || v_backup_table;
            EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table;
        END IF;
        
        -- Update strategy configuration
        create_strategy_config(p_table_name, 'INTERVAL', p_partition_column, p_interval_value);
        
        log_strategy_operation('MIGRATE_INTERVAL', p_table_name, 'INTERVAL', 'SUCCESS', 'Migration completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MIGRATE_INTERVAL', p_table_name, 'INTERVAL', 'ERROR', SQLERRM);
            RAISE;
    END migrate_to_interval_partitioning;
    
    PROCEDURE migrate_to_reference_partitioning(
        p_table_name        IN VARCHAR2,
        p_parent_table      IN VARCHAR2,
        p_foreign_key       IN VARCHAR2,
        p_preserve_data     IN BOOLEAN DEFAULT TRUE
    ) IS
        v_backup_table VARCHAR2(128);
        v_sql VARCHAR2(4000);
    BEGIN
        log_strategy_operation('MIGRATE_REFERENCE', p_table_name, 'REFERENCE', 'STARTED', 'Starting migration to reference partitioning');
        
        -- Create backup table if preserving data
        IF p_preserve_data THEN
            v_backup_table := p_table_name || '_BACKUP_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISS');
            v_sql := 'CREATE TABLE ' || v_backup_table || ' AS SELECT * FROM ' || p_table_name;
            EXECUTE IMMEDIATE v_sql;
        END IF;
        
        -- Drop original table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Recreate table with reference partitioning
        v_sql := 'CREATE TABLE ' || p_table_name || ' PARTITION BY REFERENCE (' || p_foreign_key || ') ' ||
                 'AS SELECT * FROM ' || v_backup_table || ' WHERE 1=0';
        
        EXECUTE IMMEDIATE v_sql;
        
        -- Restore data if preserving
        IF p_preserve_data THEN
            EXECUTE IMMEDIATE 'INSERT INTO ' || p_table_name || ' SELECT * FROM ' || v_backup_table;
            EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table;
        END IF;
        
        -- Update strategy configuration
        create_strategy_config(p_table_name, 'REFERENCE', p_foreign_key);
        
        log_strategy_operation('MIGRATE_REFERENCE', p_table_name, 'REFERENCE', 'SUCCESS', 'Migration completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MIGRATE_REFERENCE', p_table_name, 'REFERENCE', 'ERROR', SQLERRM);
            RAISE;
    END migrate_to_reference_partitioning;
    
    -- Strategy analysis procedures
    FUNCTION analyze_table_for_partitioning(
        p_table_name IN VARCHAR2
    ) RETURN partition_analysis_rec IS
        v_analysis partition_analysis_rec;
        v_current_strategy VARCHAR2(20);
        v_partition_count NUMBER;
        v_total_size_mb NUMBER;
    BEGIN
        -- Get current partitioning info
        IF is_partitioned(p_table_name) THEN
            SELECT partition_type
            INTO v_current_strategy
            FROM user_part_tables
            WHERE table_name = UPPER(p_table_name);
            
            SELECT COUNT(*)
            INTO v_partition_count
            FROM user_tab_partitions
            WHERE table_name = UPPER(p_table_name);
        ELSE
            v_current_strategy := 'NONE';
            v_partition_count := 1;
        END IF;
        
        -- Get size information
        SELECT ROUND(SUM(bytes) / 1024 / 1024, 2)
        INTO v_total_size_mb
        FROM user_segments
        WHERE segment_name = UPPER(p_table_name);
        
        -- Build analysis record
        v_analysis.table_name := UPPER(p_table_name);
        v_analysis.current_strategy := v_current_strategy;
        v_analysis.partition_count := v_partition_count;
        v_analysis.total_size_mb := v_total_size_mb;
        v_analysis.avg_partition_size_mb := ROUND(v_total_size_mb / v_partition_count, 2);
        v_analysis.max_partition_size_mb := v_total_size_mb; -- Simplified
        v_analysis.min_partition_size_mb := v_total_size_mb; -- Simplified
        v_analysis.last_analyzed := SYSDATE;
        
        -- Simple recommendation logic
        IF v_total_size_mb > 1000 THEN
            v_analysis.recommended_strategy := 'RANGE';
        ELSIF v_total_size_mb > 100 THEN
            v_analysis.recommended_strategy := 'HASH';
        ELSE
            v_analysis.recommended_strategy := 'NONE';
        END IF;
        
        v_analysis.migration_complexity := 'MEDIUM'; -- Simplified
        
        RETURN v_analysis;
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('ANALYZE_TABLE', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END analyze_table_for_partitioning;
    
    FUNCTION get_partitioning_recommendations(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                'RANGE' as strategy_type,
                'Recommended for time-based data' as description,
                'HIGH' as priority,
                'MEDIUM' as complexity
            FROM dual
            UNION ALL
            SELECT 
                'HASH' as strategy_type,
                'Recommended for evenly distributed data' as description,
                'MEDIUM' as priority,
                'LOW' as complexity
            FROM dual
            UNION ALL
            SELECT 
                'LIST' as strategy_type,
                'Recommended for discrete value sets' as description,
                'LOW' as priority,
                'LOW' as complexity
            FROM dual;
            
        RETURN v_cursor;
    END get_partitioning_recommendations;
    
    FUNCTION analyze_partition_effectiveness(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                partition_name,
                num_rows,
                ROUND(blocks * 8192 / 1024 / 1024, 2) as size_mb,
                last_analyzed,
                CASE 
                    WHEN num_rows = 0 THEN 'EMPTY'
                    WHEN blocks < 8 THEN 'SMALL'
                    WHEN blocks > 1000 THEN 'LARGE'
                    ELSE 'MEDIUM'
                END as size_category
            FROM user_tab_partitions
            WHERE table_name = UPPER(p_table_name)
            ORDER BY blocks DESC;
            
        RETURN v_cursor;
    END analyze_partition_effectiveness;
    
    -- Strategy optimization procedures
    PROCEDURE optimize_partition_strategy(
        p_table_name IN VARCHAR2,
        p_force_recommendation IN BOOLEAN DEFAULT FALSE
    ) IS
        v_analysis partition_analysis_rec;
    BEGIN
        v_analysis := analyze_table_for_partitioning(p_table_name);
        
        log_strategy_operation('OPTIMIZE', p_table_name, v_analysis.recommended_strategy, 'STARTED', 
                              'Starting strategy optimization');
        
        -- Apply optimization based on analysis
        CASE v_analysis.recommended_strategy
            WHEN 'RANGE' THEN
                -- Implement range partitioning optimization
                NULL;
            WHEN 'HASH' THEN
                -- Implement hash partitioning optimization
                NULL;
            WHEN 'LIST' THEN
                -- Implement list partitioning optimization
                NULL;
            ELSE
                log_strategy_operation('OPTIMIZE', p_table_name, NULL, 'INFO', 'No optimization needed');
        END CASE;
        
        log_strategy_operation('OPTIMIZE', p_table_name, v_analysis.recommended_strategy, 'SUCCESS', 
                              'Strategy optimization completed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('OPTIMIZE', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END optimize_partition_strategy;
    
    PROCEDURE rebalance_partitions(
        p_table_name IN VARCHAR2,
        p_target_size_mb IN NUMBER DEFAULT 1000
    ) IS
    BEGIN
        log_strategy_operation('REBALANCE', p_table_name, NULL, 'STARTED', 
                              'Starting partition rebalancing');
        
        -- Implementation would depend on current partitioning strategy
        -- This is a placeholder for the actual rebalancing logic
        
        log_strategy_operation('REBALANCE', p_table_name, NULL, 'SUCCESS', 
                              'Partition rebalancing completed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('REBALANCE', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END rebalance_partitions;
    
    PROCEDURE consolidate_small_partitions(
        p_table_name IN VARCHAR2,
        p_min_size_mb IN NUMBER DEFAULT 100
    ) IS
    BEGIN
        log_strategy_operation('CONSOLIDATE', p_table_name, NULL, 'STARTED', 
                              'Starting small partition consolidation');
        
        -- Implementation would identify and merge small partitions
        -- This is a placeholder for the actual consolidation logic
        
        log_strategy_operation('CONSOLIDATE', p_table_name, NULL, 'SUCCESS', 
                              'Small partition consolidation completed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('CONSOLIDATE', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END consolidate_small_partitions;
    
    -- Strategy validation procedures
    FUNCTION validate_partition_strategy(
        p_table_name IN VARCHAR2
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                'PARTITION_COUNT' as check_type,
                CASE 
                    WHEN COUNT(*) > 1000 THEN 'WARNING: Too many partitions'
                    WHEN COUNT(*) < 2 THEN 'WARNING: Too few partitions'
                    ELSE 'OK'
                END as status,
                COUNT(*) as value
            FROM user_tab_partitions
            WHERE table_name = UPPER(p_table_name)
            GROUP BY 'PARTITION_COUNT'
            UNION ALL
            SELECT 
                'EMPTY_PARTITIONS' as check_type,
                CASE 
                    WHEN COUNT(*) > 0 THEN 'WARNING: Empty partitions found'
                    ELSE 'OK'
                END as status,
                COUNT(*) as value
            FROM user_tab_partitions
            WHERE table_name = UPPER(p_table_name)
            AND num_rows = 0;
            
        RETURN v_cursor;
    END validate_partition_strategy;
    
    PROCEDURE validate_partition_columns(
        p_table_name IN VARCHAR2,
        p_partition_column IN VARCHAR2
    ) IS
        v_column_exists BOOLEAN := FALSE;
    BEGIN
        -- Check if column exists
        SELECT COUNT(*)
        INTO v_column_exists
        FROM user_tab_columns
        WHERE table_name = UPPER(p_table_name)
        AND column_name = UPPER(p_partition_column);
        
        IF NOT v_column_exists THEN
            log_strategy_operation('VALIDATE_COLUMN', p_table_name, NULL, 'ERROR', 
                                  'Partition column does not exist');
            RAISE_APPLICATION_ERROR(-20003, 'Partition column ' || p_partition_column || ' does not exist');
        END IF;
        
        log_strategy_operation('VALIDATE_COLUMN', p_table_name, p_partition_column, 'SUCCESS', 
                              'Partition column validation passed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('VALIDATE_COLUMN', p_table_name, p_partition_column, 'ERROR', SQLERRM);
            RAISE;
    END validate_partition_columns;
    
    -- Strategy monitoring procedures
    FUNCTION get_strategy_usage_stats(
        p_table_name IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                t.table_name,
                pt.partition_type,
                COUNT(p.partition_name) as partition_count,
                SUM(p.num_rows) as total_rows,
                ROUND(SUM(p.blocks * 8192) / 1024 / 1024, 2) as total_size_mb
            FROM user_tables t
            LEFT JOIN user_part_tables pt ON t.table_name = pt.table_name
            LEFT JOIN user_tab_partitions p ON t.table_name = p.table_name
            WHERE t.partitioned = 'YES'
            AND (p_table_name IS NULL OR t.table_name = UPPER(p_table_name))
            GROUP BY t.table_name, pt.partition_type
            ORDER BY t.table_name;
            
        RETURN v_cursor;
    END get_strategy_usage_stats;
    
    PROCEDURE monitor_strategy_performance(
        p_table_name IN VARCHAR2
    ) IS
    BEGIN
        log_strategy_operation('MONITOR_PERF', p_table_name, NULL, 'INFO', 
                              'Strategy performance monitoring started');
        
        -- Implementation would include performance monitoring logic
        -- This is a placeholder for the actual monitoring logic
        
        log_strategy_operation('MONITOR_PERF', p_table_name, NULL, 'SUCCESS', 
                              'Strategy performance monitoring completed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('MONITOR_PERF', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END monitor_strategy_performance;
    
    -- Utility procedures
    PROCEDURE generate_migration_script(
        p_table_name        IN VARCHAR2,
        p_target_strategy   IN VARCHAR2,
        p_script_type       IN VARCHAR2 DEFAULT 'DDL'
    ) IS
    BEGIN
        log_strategy_operation('GENERATE_SCRIPT', p_table_name, p_target_strategy, 'INFO', 
                              'Migration script generation requested');
        
        -- Implementation would generate the actual migration script
        -- This is a placeholder for the actual script generation logic
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('GENERATE_SCRIPT', p_table_name, p_target_strategy, 'ERROR', SQLERRM);
            RAISE;
    END generate_migration_script;
    
    PROCEDURE estimate_migration_impact(
        p_table_name        IN VARCHAR2,
        p_target_strategy   IN VARCHAR2
    ) IS
    BEGIN
        log_strategy_operation('ESTIMATE_IMPACT', p_table_name, p_target_strategy, 'INFO', 
                              'Migration impact estimation requested');
        
        -- Implementation would estimate the migration impact
        -- This is a placeholder for the actual impact estimation logic
        
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('ESTIMATE_IMPACT', p_table_name, p_target_strategy, 'ERROR', SQLERRM);
            RAISE;
    END estimate_migration_impact;
    
    PROCEDURE rollback_strategy_migration(
        p_table_name IN VARCHAR2,
        p_backup_table IN VARCHAR2
    ) IS
    BEGIN
        log_strategy_operation('ROLLBACK', p_table_name, NULL, 'STARTED', 
                              'Starting migration rollback');
        
        -- Drop current table
        EXECUTE IMMEDIATE 'DROP TABLE ' || p_table_name;
        
        -- Restore from backup
        EXECUTE IMMEDIATE 'CREATE TABLE ' || p_table_name || ' AS SELECT * FROM ' || p_backup_table;
        
        log_strategy_operation('ROLLBACK', p_table_name, NULL, 'SUCCESS', 
                              'Migration rollback completed');
                              
    EXCEPTION
        WHEN OTHERS THEN
            log_strategy_operation('ROLLBACK', p_table_name, NULL, 'ERROR', SQLERRM);
            RAISE;
    END rollback_strategy_migration;
    
END partition_strategy_pkg;
/
